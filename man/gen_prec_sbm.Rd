% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_prec_sbm.R
\name{gen_prec_sbm}
\alias{gen_prec_sbm}
\title{Block-Structured Precision Matrix based on SBM}
\usage{
gen_prec_sbm(
  d,
  block.sizes = NULL,
  K = 3,
  prob.mat = NULL,
  within.prob = 0.25,
  between.prob = 0.05,
  weight.mat = NULL,
  weight.dists = list("gamma", "unif"),
  weight.paras = list(c(shape = 10000, rate = 100), c(min = 0, max = 5)),
  cond.target = 100
)
}
\arguments{
\item{d}{An integer specifying the number of variables (dimensions).}

\item{block.sizes}{An integer vector (default = \code{NULL}) specifying
the size of each group. If \code{NULL}, the \eqn{d} variables are divided
as evenly as possible across \eqn{K} groups.}

\item{K}{An integer (default = 3) specifying the number of groups.
Ignored if \code{block.sizes} is provided; then \code{K <- length(block.sizes)}.}

\item{prob.mat}{A \eqn{K}-by-\eqn{K} symmetric matrix (default = \code{NULL})
specifying the Bernoulli rates. Element (i,j) gives the probability of
creating an edge between vertices from groups i and j. If \code{NULL},
a matrix with \code{within.prob} on the diagonal and \code{between.prob}
off-diagonal is used.}

\item{within.prob}{A scalar in [0,1] (default = 0.25) specifying
the probability of creating an edge between vertices within the same group.
This argument is used only when \code{prob.mat = NULL}.}

\item{between.prob}{A scalar in [0,1] (default = 0.05) specifying
the probability of creating an edge between vertices from different groups.
This argument is used only when \code{prob.mat = NULL}.}

\item{weight.mat}{A \eqn{d}-by-\eqn{d} symmetric matrix (default = \code{NULL})
specifying the edge weights. If \code{NULL}, weights are generated block-wise
according to \code{weight.dists} and \code{weight.paras}.}

\item{weight.dists}{A list (default = \code{list("gamma", "unif")})
specifying the sampling distribution for each block of weights.
Its length determines how the distributions are assigned:
\itemize{
\item length = 1: Same specification for all blocks.
\item length = 2: First for within-group blocks, second for between-group
blocks.
\item length = \eqn{K + K(K-1)/2}: Full specification for each block.
The first \eqn{K} elements correspond to within-group blocks with indices 1,
\dots, K, and the remaining \eqn{K(K-1)/2} elements correspond to
between-group blocks ordered as (1,2), (1,3), \dots, (1,K), (2,3), \dots,
(K-1,K).
}
Each element of \code{weight.dists} can be:
\enumerate{
\item A string specifying the distribution family. Accepted distributions
(base R samplers in parentheses) include: \itemize{
\item "beta": Beta distribution (\code{\link[stats]{rbeta}})
\item "cauchy": Cauchy distribution (\code{\link[stats]{rcauchy}}).
\item "chisq": Chi-squared distribution (\code{\link[stats]{rchisq}}).
\item "exp": Exponential distribution (\code{\link[stats]{rexp}}).
\item "f": F distribution (\code{\link[stats]{rf}}).
\item "gamma": Gamma distribution (\code{\link[stats]{rgamma}}).
\item "lnorm": Log normal distribution (\code{\link[stats]{rlnorm}}).
\item "norm": Normal distribution (\code{\link[stats]{rnorm}}).
\item "t": Student's t distribution (\code{\link[stats]{rt}}).
\item "unif": Uniform distribution (\code{\link[stats]{runif}}).
\item "weibull": Weibull distribution (\code{\link[stats]{rweibull}}).
}
\item A user-supplied function used for sampling. The function must accept
an argument \code{n} specifying the number of samples.
}}

\item{weight.paras}{A list (default =
\code{list(c(shape = 1e4, rate = 1e2), c(min = 0, max = 5))}) specifying
the parameters associated with \code{weight.dists}. It must follow the same
length rules as \code{weight.dists}. Each element should be a named vector
or list suitable for the corresponding sampler.}

\item{cond.target}{A scalar (default = 100) specifying the target condition
number for the precision matrix. A diagonal shift is applied so that
the smallest eigenvalue satisfies
\eqn{\lambda_{\min} \geq \lambda_{\max}/\code{cond.target}},
ensuring both positive definiteness and numerical stability.}
}
\value{
A list with the following components:
\describe{
\item{Omega}{The precision matrix with SBM block structure.}
\item{Sigma}{The covariance matrix, i.e., the inverse of \code{Omega}.}
\item{sparsity}{Proportion of zero entries in \code{Omega}.}
\item{membership}{An integer vector specifying the group membership.}
}
}
\description{
Generate a precision matrix that exhibits block structure induced by
a stochastic block model (SBM).
}
\details{
\strong{Edge sampling.}
Within- and between-group edges are sampled independently according to
Bernoulli distributions specified by \code{prob.mat}, or by \code{within.prob}
and \code{between.prob} if \code{prob.mat} is not supplied.

\strong{Weight sampling.}
Conditional on the adjacency structure, edge weights are sampled block-wise
from samplers specified in \code{weight.dists} and \code{weight.paras}.
The length of \code{weight.dists} (and \code{weight.paras}) determines how
weight distributions are assigned:
\itemize{
\item length = 1: Same specification for all blocks.
\item length = 2: first for within-group blocks, second for between-group
blocks.
\item length = \eqn{K + K(K - 1)/2}: Full specification for each block.
}

\strong{Block indexing.}
The order for blocks is:
\itemize{
\item Within-group blocks: Indices 1, \dots, K.
\item Between-group blocks: \eqn{K(K-1)/2} blocks in order (1,2), (1,3),
\dots, (1,K), (2,3), \dots, (K-1,K).
}

\strong{Positive definiteness.}
The weighted adjacency matrix is symmetrized and used as the precision matrix
\eqn{\Omega_0}. Since arbitrary block-structured weights may not be positive
definite, a diagonal adjustment is applied to control the eigenvalue spectrum.
Specifically, let \eqn{\lambda_{\max}} and \eqn{\lambda_{\min}} denote
the largest and smallest eigenvalues of the initial matrix. A scalar
\eqn{\tau} is added to the diagonal so that
\deqn{\lambda_{\min}(\Omega_0 + \tau I) \;\geq\;
\lambda_{\max} / \code{cond.target},
}
which ensures both positive definiteness and that the condition number
does not exceed \code{cond.target}. This guarantees numerical stability even
in high-dimensional settings.
}
\examples{
## reproducibility for everything
set.seed(1234)

## user-defined sampler
my_gamma <- function(n) {
  rgamma(n, shape = 10, scale = 0.5)
}

sim <- gen_prec_sbm(d = 20, K = 3,
                    within.prob = 0.25, between.prob = 0.05,
                    weight.dists = list(my_gamma, "unif"),
                    weight.paras = list(NULL, c(min = 0, max = 5)),
                    cond.target = 100)

}
