% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sggm.R
\name{sggm}
\alias{sggm}
\title{Sparse-Group Graphical Model}
\usage{
sggm(
  X,
  n = nrow(X),
  groups,
  penalty,
  diag.ind = TRUE,
  diag.grp = TRUE,
  diag.include = FALSE,
  lambda = NULL,
  alpha = NULL,
  gamma = NULL,
  nlambda = 10,
  lambda.min.ratio = 0.01,
  growiter.lambda = 30,
  tol.lambda = 0.001,
  maxiter.lambda = 50,
  rho = 2,
  tau.incr = 2,
  tau.decr = 2,
  nu = 10,
  tol.abs = 1e-04,
  tol.rel = 1e-04,
  maxiter = 10000,
  crit = "BIC",
  kfold = 5,
  ebic.tuning = 0.5
)
}
\arguments{
\item{X}{\enumerate{
\item An n-by-p data matrix with sample size n and dimension p.
\item A p-by-p sample covariance/correlation matrix with dimension p.
}}

\item{n}{An integer (default = the number of columns of \code{X}) specifying
the sample size. This is only required when the input matrix \code{X} is a
p-by-p sample covariance/correlation matrix with dimension p.}

\item{groups}{An integer vector specifying the group membership. The group
sizes must be consistent with the dimension p.}

\item{penalty}{A character string specifying the penalty for estimating
precision matrix. Available options include: \enumerate{
\item "adapt": adaptive lasso \insertCite{zou2006adaptive,fan2009network}{grasps}.
\item "lasso": lasso \insertCite{tibshirani1996regression,friedman2008sparse}{grasps}.
\item "mcp": minimax concave penalty \insertCite{zhang2010nearly}{grasps}.
\item "scad": smoothly clipped absolute deviation \insertCite{fan2001variable,fan2009network}{grasps}.
}}

\item{diag.ind}{A boolean (default = TRUE) specifying whether to penalize
the diagonal elements.}

\item{diag.grp}{A boolean (default = TRUE) specifying whether to penalize
the within-group blocks.}

\item{diag.include}{A boolean (default = FALSE) specifying whether to include
the diagonal entries in the penalty for within-group blocks when
\code{diag.grp = TRUE}.}

\item{lambda}{A grid of non-negative scalars for the regularization parameter.
The default is \code{NULL}, which generates its own \code{lambda} sequence
based on \code{nlambda} and \code{lambda.min.ratio}.}

\item{alpha}{A grid of scalars in [0,1] specifying the parameter leveraging
the element-wise individual L1 penalty and the block-wise group L2 penalty.
An alpha of 1 corresponds to the element penalty only; an alpha of 0
corresponds to the group penalty only. The default values is a sequence from
0.05 to 0.95 with increments of 0.05.}

\item{gamma}{A scalar specifying the hyperparameter for the chosen
\code{penalty}. Default values: \enumerate{
\item "adapt": 0.5
\item "mcp": 3
\item "scad": 3.7
}}

\item{nlambda}{An integer (default = 10) specifying the number of
\code{lambda} values to be generated when \code{lambda = NULL}.}

\item{lambda.min.ratio}{A scalar (default = 0.01) specifying the fraction of
the maximum \code{lambda} value \eqn{\lambda_{max}} to generate the minimum
\code{lambda} \eqn{\lambda_{min}}. If \code{lambda = NULL}, the program
automatically generates a \code{lambda} grid as a sequence of length
\code{nlambda} in log scale, starting from \eqn{\lambda_{min}} to
\eqn{\lambda_{max}}.}

\item{growiter.lambda}{An integer (default = 30) specifying the maximum
number of exponential growth steps during the initial search for an
admissible upper bound \eqn{\lambda_{\max}}.}

\item{tol.lambda}{A scalar (default = 1e-03) specifying the relative
tolerance for the bisection stopping rule on the interval width.}

\item{maxiter.lambda}{An integer (default = 50) specifying the maximum number
of bisection iterations in the line search for  \eqn{\lambda_{\max}}.}

\item{rho}{A scalar > 0 (default = 2) specifying the ADMM
augmented-Lagrangian penalty parameter (often called the ADMM step size).
Larger values typically put more weight on enforcing the consensus
constraints each iteration; smaller values yield more conservative updates.}

\item{tau.incr}{A scalar > 1 (default = 2) specifying the multiplicative
factor used to increase \code{rho} when the primal residual dominates the
dual residual in ADMM.}

\item{tau.decr}{A scalar > 1 (default = 2) specifying the multiplicative
factor used to decrease \code{rho} when the dual residual dominates the
primal residual in ADMM.}

\item{nu}{A scalar > 1 (default = 10) controlling how aggressively \code{rho}
is rescaled in the adaptive-\code{rho} scheme (residual balancing).}

\item{tol.abs}{A scalar > 0 (default = 1e-04) specifying the absolute
tolerance for ADMM stopping (applied to primal/dual residual norms).}

\item{tol.rel}{A scalar > 0 (default = 1e-04) specifying the relative
tolerance for ADMM stopping (applied to primal/dual residual norms).}

\item{maxiter}{An integer (default = 1e+04) specifying the maximum number of
ADMM iterations.}

\item{crit}{A string (default = "BIC") specifying the parameter selection
method to use. Available options include: \enumerate{
\item "AIC": Akaike information criterion \insertCite{akaike1973information}{grasps}.
\item "BIC": Bayesian information criterion \insertCite{schwarz1978estimating}{grasps}.
\item "EBIC": extended Bayesian information criterion \insertCite{foygel2010extended}{grasps}.
\item "HBIC": high dimensional Bayesian information criterion \insertCite{wang2013calibrating,fan2017high}{grasps}.
\item "CV": k-fold cross validation with negative log-likelihood loss.
}}

\item{kfold}{An integer (default = 5) specifying the number of folds used for
\code{crit = "CV"}.}

\item{ebic.tuning}{A scalar (default = 0.5) specifying the tuning parameter to
calculate for \code{crit = "EBIC"}.}
}
\value{
A list containing the following components:
\describe{
\item{hatOmega}{The estimated precision matrix.}
\item{lambda}{The optimal regularization parameter.}
\item{alpha}{The optimal penalty balancing parameter.}
\item{initial}{The initial estimate of \code{hatOmega} when \code{penalty} is
set to \code{"adapt"}, \code{"mcp"}, or \code{"scad"}.}
\item{gamma}{The optimal hyperparameter when \code{penalty} is set to
\code{"adapt"}, \code{"mcp"}, or \code{"scad"}.}
\item{iterations}{The number of ADMM iterations.}
\item{lambda.grid}{The actual lambda grid used in the program.}
\item{alpha.grid}{The actual alpha grid used in the program.}
\item{lambda.safe}{The bisection-refined upper bound \eqn{\lambda_{\max}},
corresponding to \code{alpha.grid}, when \code{lambda = NULL}.}
\item{loss}{The optimal k-fold loss when \code{crit = "CV"}.}
\item{CV.loss}{Matrix of CV losses, with rows for parameter combinations and
columns for CV folds, when \code{crit = "CV"}.}
\item{score}{The optimal information criterion score when \code{crit} is set
to \code{"AIC"}, \code{"BIC"}, \code{"EBIC"}, or \code{"HBIC"}.}
\item{IC.score}{The information criterion score for each parameter
combination when \code{crit} is set to \code{"AIC"}, \code{"BIC"},
\code{"EBIC"}, or \code{"HBIC"}.}
}
}
\description{
Provide a collection of statistical methods that incorporate both
element-wise and group-wise penalties to estimate a precision matrix.
}
\references{
\insertAllCited{}
}
